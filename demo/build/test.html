<html>

<head>
<title>TEST</title>
<style type="text/css">
    html,body{ width: 100%; height:100%; padding:0; margin: 0;}
</style>
<meta http-equiv='content-type' content='text/html; charset=ISO-8859-1'>

<script type='text/javascript' src='js/gui/jquery-1.5.1.min.js'></script>

<!-- MATH Libraries //-->
<script type='text/javascript' src='js/math/gl-matrix-min.js'></script>
<!-- WEBGL Libraries //-->
<script type='text/javascript' src='js/webgl/Globals.js'></script>
<script type='text/javascript' src='js/webgl/Utils.js'></script>
<script type='text/javascript' src='js/webgl/Program.js'></script>
<script type='text/javascript' src='js/webgl/Scene.js'></script>
<script type='text/javascript' src='js/webgl/Axis.js'></script>
<script type='text/javascript' src='js/webgl/Floor.js'></script>
<script type='text/javascript' src='js/webgl/Camera.js'></script>
<script type='text/javascript' src='js/webgl/CameraInteractor.js'></script>
<script type='text/javascript' src='js/webgl/SceneTransforms.js'></script>
<script type='text/javascript' src='js/webgl/WebGLApp.js'></script>



<script id="shader-vs" type="x-shader/x-vertex">

attribute vec3 aVertexPosition;
attribute vec3 aVertexNormal;
attribute vec4 aVertexColor;

uniform mat4 uMVMatrix;
uniform mat4 uPMatrix;
uniform mat4 uNMatrix;
uniform vec3 uLightPosition;
uniform vec4 uMaterialDiffuse;
uniform bool uWireframe;
uniform bool uPerVertexColor;
uniform bool uUpdateLight;
uniform vec3 uTranslation;
uniform bool uTranslate;

varying vec3 vNormal;
varying vec3 vLightRay;
varying vec3 vEyeVec;
varying vec4 vFinalColor;


void main(void) {
    if (uWireframe) {
        if (uPerVertexColor) {
            vFinalColor = aVertexColor;
        } else {
            vFinalColor = uMaterialDiffuse;
        }
    }

    //Transformed vertex position
    vec3 vecPosition = aVertexPosition;
    if (uTranslate) {
        vecPosition += uTranslation;
    }

    vec4 vertex = uMVMatrix * vec4(vecPosition, 1.0);

    //Transformed normal position
    vNormal = vec3(uNMatrix * vec4(aVertexNormal, 1.0));

    //Transformed light position
    vec4 light = vec4(uLightPosition, 1.0);

    if (uUpdateLight) {
        light = uMVMatrix * vec4(uLightPosition, 1.0);
    }

    //Light position
    vLightRay = vertex.xyz - light.xyz;

    //Vector Eye
    vEyeVec = -vec3(vertex.xyz);

    //Final vertex position
    gl_Position = uPMatrix * vertex;

}

</script>

<script id="shader-fs" type="x-shader/x-fragment">
#ifdef GL_ES
precision highp float;
#endif

uniform bool uWireframe;
uniform vec4 uLightAmbient;
uniform vec4 uLightDiffuse;
uniform vec4 uLightSpecular;
uniform vec4 uMaterialAmbient;
uniform vec4 uMaterialDiffuse;
uniform vec4 uMaterialSpecular;
uniform float uShininess;       

varying vec3 vNormal;
varying vec3 vLightRay;
varying vec3 vEyeVec;
varying vec4 vFinalColor;

void main(void) {
    if (uWireframe) {
        gl_FragColor = vFinalColor;
    } else {
        vec3 L = normalize(vLightRay);
        vec3 N = normalize(vNormal);

        //Lambert's cosine law
        float lambertTerm = dot(N, -L);

        //Ambient Term  
        vec4 Ia = uLightAmbient * uMaterialAmbient;

        //Diffuse Term
        vec4 Id = vec4(0.0, 0.0, 0.0, 1.0);

        //Specular Term
        vec4 Is = vec4(0.0, 0.0, 0.0, 1.0);

        if (lambertTerm > 0.0) {
            Id = uLightDiffuse * uMaterialDiffuse * lambertTerm;
            vec3 E = normalize(vEyeVec);
            vec3 R = reflect(L, N);
            float specular = pow(max(dot(R, E), 0.0), uShininess);
            Is = uLightSpecular * uMaterialSpecular * specular;
        }

        //Final color
        vec4 finalColor = Ia + Id + Is;
        finalColor.a = 1.0;
        gl_FragColor = finalColor;
    }

}

</script>

<script id='code-js' type="text/javascript">
var updateLightPosition = false;
var camera = null;
var interactor = null;
var transforms = null;

var ball = [];
var BALL_GRAVITY = 9.8;
var NUM_BALLS = 10;
var sceneTime = 0.0;

function configure() {
    gl.clearColor(0.3, 0.3, 0.3, 1.0);
    gl.clearDepth(100.0);
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);

    //Creates and sets up the camera location
    //CAMERA_ORBITING_TYPE
    //CAMERA_TRACKING_TYPE
    camera = new Camera(CAMERA_ORBITING_TYPE);
    camera.goHome([0, 2, 70]);
    camera.setFocus([0.0, 0.0, 0.0]);
    camera.hookRenderer = draw;

    //Creates and sets up the mouse and keyboard interactor
    interactor = new CameraInteractor(camera, document.getElementById('canvas-element-id'));

    //Scene Transforms
    transforms = new SceneTransforms(camera);

    //init transforms
    transforms.init();

    //create program variable that maps the uniform uTranslation
    prg.uTranslation = gl.getUniformLocation(prg, "uTranslation");
    gl.uniform3fv(prg.uTranslation, [0, 0, 0]);

    //create program variable that maps the uniform uTranslate
    prg.uTranslate = gl.getUniformLocation(prg, "uTranslate");
    gl.uniform1i(prg.uTranslate, false);

}


/**
 * Loads the scene
 */
function load() {
    Floor.build(80, 2);
    Axis.build(82);
    // Scene.addObject(Floor);
    Scene.addObject(Axis);

    Scene.addObject(createBall(10,0,0,0,30,30));
    // var points=[6.0,6.0,0.0,
    //             6.0,-6.0,0.0,
    //             0.0,0.0,0.0,
    //             -6.0,-6.0,0.0,
    //             -6.0,6.0,0.0]
    // Scene.addObject(drawArea(points));

    // Scene.loadObject('models/geometry/ball.json','ball');
    // Scene.loadObject('models/geometry/flag.json','flag');
    // Scene.loadObject('models/geometry/test.json','test');

    
}

// function drawArea(points){
//     //三角形算法
//     return {
//         "wireframe": false,
//         "vertices":points,
//         "indices": [0,1,2,2,3,4,4,2,0]
//     }
// }

function createBall(r, x, y, z, xd, yd) {
    var color=[1.0,0.0,0.0,1.0];

    var Info = [];
    //Y
    var YsD = 2 * r / (yd + 1);
    var Ytop = y + r;

    Info.push({y:Ytop});
    for (var i = 0; i < yd; i++) {
        var yV = Ytop - YsD * (i + 1);
        Info.push({y:yV});
        console.log(yV);
    }
    Info.push({y:y - r});

    //Angle
    var XAngle = 2 * Math.PI / xd;

    //radius
    // var radius = [];
    for (var i = 0; i < Info.length ; i++) {
        var rad;
        if(i===0 || i===(Info.length-1)){
            rad = 0;
        }else{
            rad = getRadiusByY(Info[i].y);
        }
        Info[i].radius = rad;

        Info[i].points=getCriclePoints(rad,Info[i].y);
        // radius.push(rad);
    }

    function getRadiusByY(yV){
        var thisR = Math.abs(yV-y);
        var res = Math.sqrt(Math.pow(r, 2) - Math.pow(thisR, 2));
        return res;
    }

    //point in cricle
    function getCriclePoints(useRadius,yV){
        if(useRadius==0){
            return [{x:x,y:yV,z:z}];
        }
        var points=[];
        for (var i = 0; i < xd; i++) {
            var xV = x - useRadius * Math.cos(2 * Math.PI / xd * i);
            var zV = z + useRadius * Math.sin(2 * Math.PI / xd * i);
            points.push({x:xV,y:yV,z:zV});
        }
        return points;
    }

    //to vertices
    var vert=[];
    for(var i=0,iLen=Info.length;i<iLen;i++){
        var key=Info[i].points;
        for(var j=0,jLen=key.length;j<jLen;j++){
            // console.log(key[j]);

            vert.push(key[j].x)
            vert.push(key[j].y)
            vert.push(key[j].z)
        }
        // console.log()
    }

    var indi=[];
    var scalars=[];
    for(var i=0;i<vert.length/3;i++){
        indi.push(i);
        scalars.push(color);
    }

    
    indi=[];
    // addIndiByLine(3,indi);    
    // addIndiByLine(6,indi);    

    for(var i=1;i<=yd;i++){
        addIndiByLine(i,indi);    
    }

    function addIndiByLine(line,arr){
        var start = (line-1)*xd +1;
        var end = line * xd + 1;
        var max = yd * xd + 1;

        for(var i=start;i<end;i++){
            //up 
            arr.push(i);
            arr.push((i+1)>=end?start:(i+1));
            arr.push((i-xd)<0?0:(i-xd));
            //down
            arr.push(i);
            arr.push((i+1)>=end?start:(i+1));
            var nextRow=i+xd+1;
            var nextMax=end+xd-1;
            var nextPoint=nextRow>nextMax?end:nextRow;
            nextPoint=nextPoint>max?max:nextPoint;
            arr.push(nextPoint);
        }
    }

    return {
        "wireframe": true,
        "vertices":vert,
        "indices": indi,
        "scalars":scalars,
         "diffuse"  : [1.0,0.0,0.0,1.0]
    }
}


/**
 * invoked on every rendering cycle
 */
function draw() {
    gl.viewport(0, 0, c_width, c_height);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    transforms.updatePerspective();

    try {
        gl.uniform1i(prg.uUpdateLight, updateLightPosition);


        for (var i = 0; i < Scene.objects.length; i++) {

            var object = Scene.objects[i];

            transforms.calculateModelView();
            transforms.setMatrixUniforms();

            gl.uniform1i(prg.uTranslate, false);

            //Setting uniforms
            // console.log(object.diffuse);
            gl.uniform4fv(prg.uMaterialDiffuse, object.diffuse);
            gl.uniform4fv(prg.uMaterialSpecular, object.specular);
            gl.uniform4fv(prg.uMaterialAmbient, object.ambient);

            gl.uniform1i(prg.uWireframe, object.wireframe);
            gl.uniform1i(prg.uPerVertexColor, object.perVertexColor);

            //Setting attributes
            gl.enableVertexAttribArray(prg.aVertexPosition);
            gl.disableVertexAttribArray(prg.aVertexNormal);
            gl.disableVertexAttribArray(prg.aVertexColor);

            gl.bindBuffer(gl.ARRAY_BUFFER, object.vbo);
            gl.vertexAttribPointer(prg.aVertexPosition, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(prg.aVertexPosition);

            if (!object.wireframe) {
                gl.bindBuffer(gl.ARRAY_BUFFER, object.nbo);
                gl.vertexAttribPointer(prg.aVertexNormal, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(prg.aVertexNormal);
            }

            if (object.perVertexColor) {
                gl.bindBuffer(gl.ARRAY_BUFFER, object.cbo);
                gl.vertexAttribPointer(prg.aVertexColor, 4, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(prg.aVertexColor);
            }

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, object.ibo);

            if (object.wireframe) {
                gl.drawElements(gl.LINES, object.indices.length, gl.UNSIGNED_SHORT, 0);
            } else {
                gl.drawElements(gl.TRIANGLES, object.indices.length, gl.UNSIGNED_SHORT, 0);
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

        }
    } catch (err) {
        alert(err);
        console.error(err.description);
    }
}

/**
 * Entry point. This function is invoked when the page is loaded
 */
var app = null;

function runWebGLApp() {

    app = new WebGLApp("canvas-element-id");
    app.configureGLHook = configure;
    app.loadSceneHook = load;
    app.drawSceneHook = draw;
    app.run();

    // startAnimation();

}
</script>

</head>

<body onLoad='runWebGLApp()'>

<canvas id='canvas-element-id'  >
    Your browser does not support the HTML5 canvas element.
</canvas>




</body>
</html>