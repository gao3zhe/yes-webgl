<html>

<head>
<title>TEST</title>
<style type="text/css">
    html,body{ width: 100%; height:100%; padding:0; margin: 0;}
</style>
<meta http-equiv='content-type' content='text/html; charset=ISO-8859-1'>

<script type='text/javascript' src='js/gui/jquery-1.5.1.min.js'></script>

<!-- MATH Libraries //-->
<script type='text/javascript' src='js/math/gl-matrix-min.js'></script>
<!-- WEBGL Libraries //-->
<script type='text/javascript' src='js/webgl/Globals.js'></script>
<script type='text/javascript' src='js/webgl/Utils.js'></script>
<script type='text/javascript' src='js/webgl/Program.js'></script>
<script type='text/javascript' src='js/webgl/Scene.js'></script>
<script type='text/javascript' src='js/webgl/Axis.js'></script>
<script type='text/javascript' src='js/webgl/Floor.js'></script>
<script type='text/javascript' src='js/webgl/Camera.js'></script>
<script type='text/javascript' src='js/webgl/CameraInteractor.js'></script>
<script type='text/javascript' src='js/webgl/SceneTransforms.js'></script>
<script type='text/javascript' src='js/webgl/WebGLApp.js'></script>




<script id="shader-vs" type="x-shader/x-vertex">

attribute vec3 aVertexPosition;  //顶点位置
attribute vec3 aVertexNormal;   //顶点法线
attribute vec4 aVertexColor;    //顶点颜色

uniform mat4 uMVMatrix; //模型-视见转换矩阵
uniform mat4 uPMatrix;  //透视矩阵
uniform mat4 uNMatrix;  //法线矩阵

//lights
uniform vec3 uLightPosition;

uniform vec4 uMaterialDiffuse;   //object color
uniform bool uWireframe;
uniform bool uPerVertexColor;
uniform bool uUpdateLight;
uniform vec3 uTranslation;
uniform bool uTranslate;

varying vec3 vNormal;
varying vec3 vLightRay;
varying vec3 vEyeVec;
varying vec4 vFinalColor;


void main(void) {
    if (uWireframe) {
        if (uPerVertexColor) {
            vFinalColor = aVertexColor;
        } else {
            vFinalColor = uMaterialDiffuse;
        }
    }

    //Transformed vertex position
    vec3 vecPosition = aVertexPosition;
    if (uTranslate) {
        vecPosition += uTranslation;
    }

    vec4 vertex = uMVMatrix * vec4(vecPosition, 1.0);

    //Transformed normal position
    vNormal = vec3(uNMatrix * vec4(aVertexNormal, 1.0));

    //Transformed light position
    vec4 light = vec4(uLightPosition, 1.0);

    if (uUpdateLight) {
        light = uMVMatrix * vec4(uLightPosition, 1.0);
    }

    //Light position
    vLightRay = vertex.xyz - light.xyz;

    //Vector Eye
    vEyeVec = -vec3(vertex.xyz);

    //Final vertex position
    gl_Position = uPMatrix * vertex;

}

</script>

<script id="shader-fs" type="x-shader/x-fragment">
#ifdef GL_ES
precision highp float;
#endif

uniform bool uWireframe;
uniform vec4 uLightAmbient;
uniform vec4 uLightDiffuse;
uniform vec4 uLightSpecular;
uniform vec4 uMaterialAmbient;
uniform vec4 addObject;
uniform vec4 uMaterialSpecular;
uniform vec4 uMaterialDiffuse; 



uniform float uShininess;       

varying vec3 vNormal;
varying vec3 vLightRay;
varying vec3 vEyeVec;
varying vec4 vFinalColor;

void main(void) {
    if (uWireframe) {
        gl_FragColor = vFinalColor;
    } else {
        vec3 L = normalize(vLightRay);
        vec3 N = normalize(vNormal);

        //Lambert's cosine law
        // float lambertTerm = 1.0;
        float lambertTerm = dot(N, -L);

        //Ambient Term  
        vec4 Ia = uLightAmbient * uMaterialAmbient;  //环境光 = 漫反环境颜色 * 材质环境颜色
        //Diffuse Term
        vec4 Id = vec4(0.0, 0.0, 0.0, 1.0);     //漫反射 =  
        //Specular Term
        vec4 Is = vec4(0.0, 0.0, 0.0, 1.0);     //镜面光 = 

        if (lambertTerm > 0.0) {
            Id = uLightDiffuse * uMaterialDiffuse * lambertTerm;
            vec3 E = normalize(vEyeVec);    //视见向量或者相机向量
            vec3 R = reflect(L, N);     //反射后的光照向量
            float specular = pow(max(dot(R, E), 0.0), uShininess);  //镜面系数  uShininess光泽度
            Is = uLightSpecular * uMaterialSpecular * specular;
        }

        //Final color

        // vec4 finalColor = Ia + Id + Is; //环境光 + 漫反射光 + 镜面光
        // finalColor.a = uMaterialDiffuse.a;
        // gl_FragColor = finalColor;

        gl_FragColor = vec4(Ia.rbg + Id.rgb+Is.rgb,uMaterialDiffuse.a);
    }

}

</script>


<script id='code-js' type="text/javascript">
var updateLightPosition = true;
var camera = null;
var interactor = null;
var transforms = null;

var ball = [];
var BALL_GRAVITY = 9.8;
var NUM_BALLS = 10;
var sceneTime = 0.0;

function configure() {
    gl.clearColor(0.3, 0.3, 0.3, 1.0);
    gl.clearDepth(1.0);
    
    //Enabling depth testing
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LESS);
    
    //Enabling alpha blending
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    gl.enable(gl.CULL_FACE);
    // gl.enable(gl.FACE_CULLING);
    // gl.cullFace(gl.BACK);



    // gl.disable(gl.DEPTH_TEST);
    // gl.enable(gl.BLEND);
    // gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

    //Creates and sets up the camera location
    //CAMERA_ORBITING_TYPE
    //CAMERA_TRACKING_TYPE
    camera = new Camera(CAMERA_ORBITING_TYPE);
    camera.goHome([0, 2, 70]);
    camera.setFocus([0.0, 0.0, 0.0]);
    camera.hookRenderer = draw;

    //Creates and sets up the mouse and keyboard interactor
    interactor = new CameraInteractor(camera, document.getElementById('canvas-element-id'));

    //Scene Transforms
    transforms = new SceneTransforms(camera);

    //init transforms
    transforms.init();

    //Program
    attributeList = [];

    uniformList = [ "uTranslation", 
                    "uTranslate",
                    ];
    
    Program.load(attributeList, uniformList);
    

    gl.uniform3fv(Program.uTranslation,   [0,10,0]);
    gl.uniform1i(Program.uTranslate, false);

    //light
    gl.uniform3fv(Program.uLightPosition,   [0,5,20]);
    gl.uniform3fv(Program.uLightAmbient,    [1.0,1.0,1.0,1.0]);
    gl.uniform4fv(Program.uLightDiffuse,    [1.0,1.0,1.0,1.0]);

}


/**
 * Loads the scene
 */
function load() {
    Floor.build(80, 2);
    // Axis.build(82);
    Scene.addObject(Floor);
    // Scene.addObject(Axis);
    var ball = createBall(10,0,0,0,30,30,{
        "alias":"ball",
        "wireframe": false,
        "diffuse"  : [1.0,0.0,0.0,0.4]
    });
    ball.diffuse[3] = 0.2;
    console.log(ball);
    Scene.addObject(ball);

    // Scene.loadObject('models/geometry/ball.json','ball');
    // Scene.loadObject('models/geometry/flag.json','flag');
    // Scene.loadObject('models/geometry/test.json','test');

    
}

// function drawArea(points){
//     //三角形算法
//     return {
//         "wireframe": false,
//         "vertices":points,
//         "indices": [0,1,2,2,3,4,4,2,0]
//     }
// }

/**
  * createBall
  * r:radius
  * x,y,x the center
  * xd,yd 细分
    options = {
        "alias":"ball",
        "wireframe": false,
        "diffuse"  : [1.0,1.0,0.0,1.0]
    }
  */
function createBall(r, x, y, z, xd, yd,options) {
    options = options||{};
    var color=[0.0,0.0,0.0,1.0];

    var Info = [];
    //Y
    var YsD = 2 * r / (yd + 1);
    var Ytop = y + r;

    var yVO= Math.PI/(yd+1);

    Info.push({y:Ytop});
    for (var i = 0; i < yd; i++) {
        var yV = Ytop - YsD * (i + 1);
        var yV = r*Math.cos(yVO*(i+1)).toFixed(4);
        Info.push({y:yV});
    }
    Info.push({y:y - r});

    //Angle
    var XAngle = 2 * Math.PI / xd;

    //radius
    // var radius = [];
    for (var i = 0; i < Info.length ; i++) {
        var rad;
        if(i===0 || i===(Info.length-1)){
            rad = 0;
        }else{
            rad = getRadiusByY(Info[i].y);
        }
        Info[i].radius = rad;

        Info[i].points=getCriclePoints(rad,Info[i].y);
        // radius.push(rad);
    }

    function getRadiusByY(yV){
        var thisR = Math.abs(yV-y);
        var res = Math.sqrt(Math.pow(r, 2) - Math.pow(thisR, 2));
        return res;
    }

    //point in cricle
    function getCriclePoints(useRadius,yV){
        if(useRadius==0){
            return [{x:x,y:yV,z:z}];
        }
        var points=[];
        for (var i = 0; i < xd; i++) {
            var xV = x - useRadius * Math.cos(2 * Math.PI / xd * i);
            var zV = z + useRadius * Math.sin(2 * Math.PI / xd * i);
            points.push({x:xV,y:yV,z:zV});
        }
        return points;
    }

    //to vertices
    var vert=[];
    for(var i=0,iLen=Info.length;i<iLen;i++){
        var key=Info[i].points;
        for(var j=0,jLen=key.length;j<jLen;j++){
            // console.log(key[j]);
            vert.push(key[j].x.toFixed(4))
            vert.push(key[j].y.toFixed(4))
            vert.push(key[j].z.toFixed(4))
        }
    }

    var indi=[];
    // var scalars=[];
    for(var i=0;i<vert.length/3;i++){
        // console.log(i)
        indi.push(i);
        // scalars.push(color);
    }

    
    indi=[];

    for(var i=1;i<=yd;i++){
        addIndiByLine(i,indi);    
    }
    //
    // addIndiByLine(2,indi);    

    function addIndiByLine(line,arr){
        var start = (line-1)*xd +1;
        var end = line * xd + 1;
        var max = yd * xd + 1;

        for(var i=start;i<end;i++){
            var next = i + 1;
            next = next >= end ? start : next;
            var top = i - xd;
            top = top < 0 ? 0 : top;
            //up 
            arr.push(i);
            arr.push(next);
            arr.push((i-xd)<0?0:(i-xd));
            //down
            arr.push(next);
            arr.push(i);
            var nextRow=i+xd+1;
            var nextMax=end+xd-1;
            var nextPoint=nextRow>nextMax?end:nextRow;
            nextPoint=nextPoint>max?max:nextPoint;
            arr.push(nextPoint);
        }
    }

    

    return {
        "alias":options.alias||'',
        "wireframe": options.wireframe||false,
        "vertices":vert,
        "indices": indi,
        // "scalars":scalars,
        "diffuse"  : options.diffuse||[1.0,1.0,1.0,1.0]
    }
}


/**
 * invoked on every rendering cycle
 */
function draw() {
    gl.viewport(0, 0, c_width, c_height);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    transforms.updatePerspective();

    try {
        gl.uniform1i(prg.uUpdateLight, updateLightPosition);

        for (var i = 0; i < Scene.objects.length; i++) {

            var object = Scene.objects[i];

            transforms.calculateModelView();
            transforms.setMatrixUniforms();

            gl.uniform1i(prg.uTranslate, false);

            //Setting uniforms
            // console.log(object.diffuse);
            gl.uniform4fv(prg.uMaterialDiffuse, object.diffuse);
            gl.uniform4fv(prg.uMaterialSpecular, object.specular);
            gl.uniform4fv(prg.uMaterialAmbient, object.ambient);

            gl.uniform1i(prg.uWireframe, object.wireframe);
            gl.uniform1i(prg.uPerVertexColor, object.perVertexColor);

            //Setting attributes
            gl.enableVertexAttribArray(prg.aVertexPosition);
            gl.disableVertexAttribArray(prg.aVertexNormal);
            gl.disableVertexAttribArray(prg.aVertexColor);

            gl.bindBuffer(gl.ARRAY_BUFFER, object.vbo);
            gl.vertexAttribPointer(prg.aVertexPosition, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(prg.aVertexPosition);
            // console.log(object.nbo)
            // if (!object.wireframe) {
                gl.bindBuffer(gl.ARRAY_BUFFER, object.nbo);
                gl.vertexAttribPointer(prg.aVertexNormal, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(prg.aVertexNormal);
            // }

            if (object.perVertexColor) {
                gl.bindBuffer(gl.ARRAY_BUFFER, object.cbo);
                gl.vertexAttribPointer(prg.aVertexColor, 4, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(prg.aVertexColor);
            }

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, object.ibo);

            if (object.wireframe) {
                gl.drawElements(gl.LINES, object.indices.length, gl.UNSIGNED_SHORT, 0);
            } else {
                gl.drawElements(gl.TRIANGLES, object.indices.length, gl.UNSIGNED_SHORT, 0);
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, null);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

        }
    } catch (err) {
        alert(err);
        console.error(err.description);
    }
}

/**
 * Entry point. This function is invoked when the page is loaded
 */
var app = null;

function runWebGLApp() {
    app = new WebGLApp("canvas-element-id");
    app.configureGLHook = configure;
    app.loadSceneHook = load;
    app.drawSceneHook = draw;
    app.run();
}
</script>

</head>

<body onLoad='runWebGLApp()'>

<canvas id='canvas-element-id'  >
    Your browser does not support the HTML5 canvas element.
</canvas>




</body>
</html>
